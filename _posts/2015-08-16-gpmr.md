---
layout: postLayout
title : GPMR install.
tags : gpu_mapreduce
category : gpu_mapreduce
---

nvidia driver 설치 드라이버를 다운받는다. 
<br>$cd Downloads $wget http://us.download.nvidia.com/XFree86/Linux-x86_64/343.22/NVIDIA-Linux-x86_64-343.22.run 
<br>이전에 설치된 드라이버를 지운다 
<br>$sudo apt-get purge nvidia* 최신 업데이트 데브 패키지를 설치한다 
<br>$sudo apt-get install nvidia-331-updates-dev 
<br>컴퓨터를 reboot한다 $sudo reboot
<br>컴퓨터의 그래픽 세션을 중지시킨다 
<br>$sudo service lightdm stop <br>다운로드한 드라이버 설치파일을 실행 가능한 파일로 바꾼다. <br>$chmod +x ~/Downloads/NVIDIA-Linux-x86_64-343.22.run <br>드라이버 설치파일을 실행한다 <br>$sudo sh ~/Downloads/NVIDIA-Linux-x86_64-343.22.run 설치확인<br> $nvidia-smi <br>그래픽카드 정보 등이 화면에 나타난다 <br>이외에도 $sudo software-properties-gtk 를 통해 설치할 수도 있다. <br>이 명령을 실행하면 gui창이 뜬다. 거기서 additional drivers를 선택하고 화면에 나타나는 여러 버전의 드라이버를 선택하면 된다. 설치가 완료돼도 Cuda 실행시 에러가 나는 경우가 있다. 이럴 경우 이해할 수 없지만 여러 버전의 gpu드라이버를 반복해서 설치하다보면 된다. <br>cuda 설치 apt-get install build-essential wget htp:// cuda download link_run nvidia <br>홈페이지에서 cuda 설치 run파일을 받는다. <br> mkdir ~/Downloads/nvidia_installers; cd ~/Downloads ./cuda_..._linux_64.run -extract=~/Downloads/nvidia_installers; sudo apt-get --purge remove nvidia-* cd ~/Downloads/nvidia_installers; 
<br>컴퓨터의 그래픽 세션을 중지시킨다 <br>sudo service lightdm stop <br>sudo killall Xorg <br>sudo ./NVIDIA-Linux-x86_64-331.62.run <br> sudo modprobe nvidia <br>sudo ./cuda-linux64-rel-....run <br>sudo ./cuda-samples-linux-....run <br> mpi 클러스터 연결 1. 모든 기기에 openmpi설치 $sudo apt-get install libopenmpi-dev openmpi-bin openmpi-doc 2. 모든 기기에 openSSH 설치 $sudo apt-get install openssh-server openssh-client 3. 마스터(M)와 슬레이브(S) 노드를 정한다. 4. 각각의 기기에 같은 이름의 사용자를 생성한다. cuda M에 'cuda'로 접속해서 public/private key pair를 생성한다. $ssh-keygen -t dsa 이 명령은 id_dsa와 id_dsa.pub 파일을 ~/.ssh folder.에 생성한다. id_dsa는 private key이며 id_dsa.pub은 public key 이다. 이제 퍼블릭 키를 슬레이브 기기에 복사해야한다. 5. s에서 scp로 m의 id_dsa.pub를 홈 디렉토리에 카피한다. $cd $scp cuda@210.119.81.152:/home/cuda/.ssh/id_dsa.pub . 6. s에서: $cd ~/.ssh $ cat id_dsa.pub >> authorized_keys 7. 이제 M에서 s로 패스워드 없이 접속 할 수 있다. 8 M에서 mpi코드를 작성한다. 9. 컴파일한다 $ mpicxx test7.c -o test7 10. s들의 ip를 담은 hostfile을 만든다. Create a file called hostfile, which contains the slave computers in the MPI cluster: $vi hostfile $ cat hostfile //호스트파일 내용 확인 210.119.81.151 12. 소스코드를 컴파일해서 생성된 test7파일을 s로 카피한다. 13. m에서 실행한다. $mpirun -hostfile hostfile -np 2 test7 gpmr gpmr 컴파일하기 위해 cudacpp, oscpp가 필요 gpmr, cudacpp, oscpp 모두 google project에서 girhub를 통해 git clone 할 수 있음 빌드 위해 obj, bin폴더를 만들어줘야 함 cudacpp 컴파일을 위해 oscpp가 필요 AsyncFileReader test빌드시 pthread link필요 makefile에서 test 부분에 -lpthread추가 cudacpp빌드를 위해 oscpp빌드로 생성된 liboscpp.a를 bin에 갖다놓은 후 build 두 번째 호스트에 gpmr컴파일 1: 복사 $ scp -r cuda@210.119.81.152:/home/cuda/gpmr . GPMR OSCPP CUDACPP CUDPP 프로젝트 모두 복사 2. Make $ cd ~/gpmr/oscpp/oscpp; sudo make clean; sudo make; $ cp ./lib/liboscpp.a ~/gpmr/cudacpp/cudacpp/lib $ cd ~/gpmr/cudacpp/cudacpp; sudo make clean; sudo make; $ cp ./lib/*.a ~/gpmr/gpmr-master/lib $ cd gpmr; sudo make clean; sudo make all; MPICH 설치되지 않아 에러남. 3. MPI 설치 $ sudo apt-get install mpich $ sudo make all; 4. CUDA Runtime Shared Object 설정 $ cd /etc/ld.so.conf.d $ sudo vi gpmr.conf <-- /usr/local/cuda/lib64 추가 $ sudo ldconfig $ cd ~/gpmr/gpmr-master/bin/linreg 5. 테스트 수행하기 5.1 텍스트 데이터 생성 $ mkdir data $ ./gen_data_file ./data/out_1mil.dat 1048576 3 $ mpirun.mpich -np 2 ./linreg cudpp 라이브러리도 새로 컴파일 해야 함. cudpp 디렉토리로 이동하여 $ cmake -i CMakeList.txt $ sudo make; cp ./lib/libcudpp.a ~/gpmr/gpmr-master/lib

<pre class="prettyprint">
var oMyAjax = {
 	xhr_async : function(sURL) {
 		var req = new XMLHttpRequest();
 		req.open("GET" , sURL , true);
 		req.send(null);

 		req.onreadystatechange = function() {
 			if (req.readyState == 4 &&  req.status == 200) {
 				this.result = req.responseText;
          this.myCallback(this.result);
        }
      }.bind(this);
    },
    myCallback : function(result) {
         document.getElementById('_player').textContent = result;
    }
}
</pre>

<br>
요놈은 qunit으로 작성한 테스트코드 입니다.

<pre class="prettyprint">
asyncTest("XHR [asyncTest_setTimeout사용] ", function() {

	var URL = "http://codepen.io/nigayo/pen/EhtGz.js";

    oMyAjax.xhr_async(URL);
  
    setTimeout(function() {
        var texts = document.getElementById('_player').textContent;
        ok(/ronaldo,29/.test(texts) , 'XHR을 통해 DOM에 ronaldo 텍스트가 있군요');
        start();
    },1000);
  
});
</pre>
[(CodePen DEMO)](http://codepen.io/nigayo/pen/BoezC?editors=001 "codepen demo page")

여기서는 1초 지연을 통해서 처리가 됩니다. 이 방법의 경우는 실제 XHR통신을 테스트 할 수 있다는 장점이 있지만 임의의 시간을 지연시간으로 지정해야 합니다.
만약 네트웍 상황이 좋지 않아 응답을 받기까지 1초 이상이 걸린다면 테스트코드는 실패할 것입니다. 그래서 넉넉한 시간(?)을 지정해야 하는 것이고요.

<br><br>

**Promise패턴을 적용한다면 어떻게 될까요?**
<br><br>

아래 코드를 보겠습니다. 

<pre class="prettyprint">
var oMyAjax = {
    myCallback : function(result) {
         document.getElementById('_player').textContent = result;
         console.log("myCallback called");
    }, 
    getPromise : function(sURL) {
      return new Promise(function(resolve, reject) {
        var req = new XMLHttpRequest();
        req.open("GET" , sURL , true);
        req.send(null);
        req.onreadystatechange = function() {
          if (req.readyState == 4 &&  req.status == 200) {
            resolve(req.responseText);
          } else if(req.status !== 200) {
            reject(Error("ajax error"));
          }
        };
      });
    }
}
</pre>

oMyAjax의 getPromise는 promise 인스턴스를 반환합니다.

아래는 테스트 코드 입니다. promise객체의 then함수로 비동기의 순서를 보장하고 있습니다.

<pre class="prettyprint">
module("XHR AsyncTest");
moduleStart(function(){
  URL = "http://codepen.io/nigayo/pen/EhtGz.js";
  BAD_URL  = "http://codepen.io/nigayo/pen/Eht3Gz.js";  
});

asyncTest("XHR [Promise 정상 URL] ", function() {
 var oP = oMyAjax.getPromise(URL);
      
        oP.then(function(res) {
                oMyAjax.myCallback(res);
        },function(err) {
                console.log('error ->  ' , err.message);
        }).then(function(){
                var texts = document.getElementById('_player').textContent;
                ok(/ronaldo,29/.test(texts) , 'XHR을 통해 DOM에 ronaldo 텍스트가 있군요');
                start();
        });
});

</pre>

then메소드를 통해서 myCallback메소드가 실행되며, 이후에(콜백함수가 끝나면) ok 함수를 통해서 테스트를 할 수 있습니다.

<br>
XHR통신 오류 상황에서의 테스트 코드도 말끔히 처리할 수 있습니다.

<pre class="prettyprint">
asyncTest("XHR [Promise 에러 URL] ", function() {

        var oP = oMyAjax.getPromise(BAD_URL);
      
        oP.then(function(res) {
                oMyAjax.myCallback(res);
        },function(err) {
                equal(err.message, 'ajax error' , 'ajax error 처리가 정상이군요');
                start();
        }).then(function(){
                //do Something..
        });
});
</pre>
[(CodePen DEMO)](http://codepen.io/nigayo/pen/CvBHf/?editors=001 "codepen demo page")

<i>*Promise는 IE와 모바일웹환경(크롬 for Android 제외)은 지원하지 않아 위 테스트코드는 먹통이여요</i>

<br> 
then 함수의 두 번째 인자로 error를 처리 할 수 있는 콜백함수를 지정할 수 있습니다.

이 콜백함수에서 필요한 error 처리를 할 수 있어 에러상황에 대한 테스트코드도 자연스럽게 구현 할 수 있습니다.

Promise를 적용하고보니 비동기테스트도 좀 할만한 것 같네요. 간단한 테스트라 다른 예외적인 상황이 또 있을지는 아직 모르겠습니다.

<br>
<br>

<em>정리하면,</em>

테스트코드를 위해서 Promise패턴을 적용하는 것은 사실 좀 고민해야 할 것 같고요.

(완전하지 않지만 처음에 설명한 것처럼 괜찮은 방법들이 있음으로)

다만 Promise패턴이 적용된 AJAX코드의 단위테스트 구현은 좀더 깔끔하고 명확한 맛이 있는 것 같네요.



